"""
This type stub file was generated by pyright.
"""

np = ...

class OffsetArithmeticError(RuntimeError):
    """
    Error caused by an Offset arithmetic error. Probably caused by bad
    writing of fields. This is considered an unreachable situation in
    normal circumstances.
    """

    ...

class IsNotNestedError(RuntimeError):
    """
    Error caused by using a Builder to write Object data when not inside
    an Object.
    """

    ...

class IsNestedError(RuntimeError):
    """
    Error caused by using a Builder to begin an Object when an Object is
    already being built.
    """

    ...

class StructIsNotInlineError(RuntimeError):
    """
    Error caused by using a Builder to write a Struct at a location that
    is not the current Offset.
    """

    ...

class BuilderSizeError(RuntimeError):
    """
    Error caused by causing a Builder to exceed the hardcoded limit of 2
    gigabytes.
    """

    ...

class BuilderNotFinishedError(RuntimeError):
    """
    Error caused by not calling `Finish` before calling `Output`.
    """

    ...

class EndVectorLengthMismatched(RuntimeError):
    """
    The number of elements passed to EndVector does not match the number
    specified in StartVector.
    """

    ...

VtableMetadataFields = ...

class Builder:
    """A Builder is used to construct one or more FlatBuffers.

    Typically, Builder objects will be used from code generated by the `flatc`
    compiler.

    A Builder constructs byte buffers in a last-first manner for simplicity and
    performance during reading.

    Internally, a Builder is a state machine for creating FlatBuffer objects.

    It holds the following internal state:
        - Bytes: an array of bytes.
        - current_vtable: a list of integers.
        - vtables: a hash of vtable entries.

    Attributes:
      Bytes: The internal `bytearray` for the Builder.
      finished: A boolean determining if the Builder has been finalized.
    """

    __slots__ = ...
    MAX_BUFFER_SIZE = ...
    def __init__(self, initialSize=...) -> None:
        """Initializes a Builder of size `initial_size`.

        The internal buffer is grown as needed.
        """
        ...
    def Output(self):  # -> bytearray:
        """Return the portion of the buffer that has been used for writing data.

        This is the typical way to access the FlatBuffer data inside the
        builder. If you try to access `Builder.Bytes` directly, you would need
        to manually index it with `Head()`, since the buffer is constructed
        backwards.

        It raises BuilderNotFinishedError if the buffer has not been finished
        with `Finish`.
        """
        ...
    def StartObject(self, numfields):  # -> None:
        """StartObject initializes bookkeeping for writing a new object."""
        ...
    def WriteVtable(self):  # -> py_type:
        """
        WriteVtable serializes the vtable for the current object, if needed.

        Before writing out the vtable, this checks pre-existing vtables for
        equality to this one. If an equal vtable is found, point the object to
        the existing vtable and return.

        Because vtable values are sensitive to alignment of object data, not
        all logically-equal vtables will be deduplicated.

        A vtable has the following format:
          <VOffsetT: size of the vtable in bytes, including this value>
          <VOffsetT: size of the object in bytes, including the vtable offset>
          <VOffsetT: offset for a field> * N, where N is the number of fields
                     in the schema for this type. Includes deprecated fields.
        Thus, a vtable is made of 2 + N elements, each VOffsetT bytes wide.

        An object has the following format:
          <SOffsetT: offset to this object's vtable (may be negative)>
          <byte: data>+
        """
        ...
    def EndObject(self):  # -> py_type:
        """EndObject writes data necessary to finish object construction."""
        ...
    def growByteBuffer(self):  # -> None:
        """Doubles the size of the byteslice, and copies the old data towards
        the end of the new buffer (since we build the buffer backwards)."""
        ...
    def Head(self):  # -> py_type:
        """Get the start of useful data in the underlying byte buffer.

        Note: unlike other functions, this value is interpreted as from the
        left.
        """
        ...
    def Offset(self):  # -> py_type:
        """Offset relative to the end of the buffer."""
        ...
    def Pad(self, n):  # -> None:
        """Pad places zeros at the current offset."""
        ...
    def Prep(self, size, additionalBytes):  # -> None:
        """
        Prep prepares to write an element of `size` after `additional_bytes`
        have been written, e.g. if you write a string, you need to align
        such the int length field is aligned to SizeInt32, and the string
        data follows it directly.
        If all you need to do is align, `additionalBytes` will be 0.
        """
        ...
    def PrependSOffsetTRelative(self, off):  # -> None:
        """
        PrependSOffsetTRelative prepends an SOffsetT, relative to where it
        will be written.
        """
        ...
    def PrependUOffsetTRelative(self, off):  # -> None:
        """Prepends an unsigned offset into vector data, relative to where it
        will be written.
        """
        ...
    def StartVector(self, elemSize, numElems, alignment):  # -> py_type:
        """
        StartVector initializes bookkeeping for writing a new vector.

        A vector has the following format:
          - <UOffsetT: number of elements in this vector>
          - <T: data>+, where T is the type of elements of this vector.
        """
        ...
    def EndVector(self, numElems=...):  # -> py_type:
        """EndVector writes data necessary to finish vector construction."""
        ...
    def CreateSharedString(self, s, encoding=..., errors=...):  # -> py_type:
        """
        CreateSharedString checks if the string is already written to the buffer
        before calling CreateString.
        """
        ...
    def CreateString(self, s, encoding=..., errors=...):  # -> py_type:
        """CreateString writes a null-terminated byte string as a vector."""
        ...
    def CreateByteVector(self, x):  # -> py_type:
        """CreateString writes a byte vector."""
        ...
    def CreateNumpyVector(self, x):  # -> py_type:
        """CreateNumpyVector writes a numpy array into the buffer."""
        ...
    def assertNested(self):  # -> None:
        """
        Check that we are in the process of building an object.
        """
        ...
    def assertNotNested(self):  # -> None:
        """
        Check that no other objects are being built while making this
        object. If not, raise an exception.
        """
        ...
    def assertStructIsInline(self, obj):  # -> None:
        """
        Structs are always stored inline, so need to be created right
        where they are used. You'll get this error if you created it
        elsewhere.
        """
        ...
    def Slot(self, slotnum):  # -> None:
        """
        Slot sets the vtable key `voffset` to the current location in the
        buffer.

        """
        ...
    def Finish(self, rootTable, file_identifier=...):  # -> py_type:
        """Finish finalizes a buffer, pointing to the given `rootTable`."""
        ...
    def FinishSizePrefixed(self, rootTable, file_identifier=...):  # -> py_type:
        """
        Finish finalizes a buffer, pointing to the given `rootTable`,
        with the size prefixed.
        """
        ...
    def Prepend(self, flags, off): ...
    def PrependSlot(self, flags, o, x, d): ...
    def PrependBoolSlot(self, *args): ...
    def PrependByteSlot(self, *args): ...
    def PrependUint8Slot(self, *args): ...
    def PrependUint16Slot(self, *args): ...
    def PrependUint32Slot(self, *args): ...
    def PrependUint64Slot(self, *args): ...
    def PrependInt8Slot(self, *args): ...
    def PrependInt16Slot(self, *args): ...
    def PrependInt32Slot(self, *args): ...
    def PrependInt64Slot(self, *args): ...
    def PrependFloat32Slot(self, *args): ...
    def PrependFloat64Slot(self, *args): ...
    def PrependUOffsetTRelativeSlot(self, o, x, d):  # -> None:
        """
        PrependUOffsetTRelativeSlot prepends an UOffsetT onto the object at
        vtable slot `o`. If value `x` equals default `d`, then the slot will
        be set to zero and no other data will be written.
        """
        ...
    def PrependStructSlot(self, v, x, d):  # -> None:
        """
        PrependStructSlot prepends a struct onto the object at vtable slot `o`.
        Structs are stored inline, so nothing additional is being added.
        In generated code, `d` is always 0.
        """
        ...
    def PrependBool(self, x):  # -> None:
        """Prepend a `bool` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependByte(self, x):  # -> None:
        """Prepend a `byte` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependUint8(self, x):  # -> None:
        """Prepend an `uint8` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependUint16(self, x):  # -> None:
        """Prepend an `uint16` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependUint32(self, x):  # -> None:
        """Prepend an `uint32` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependUint64(self, x):  # -> None:
        """Prepend an `uint64` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependInt8(self, x):  # -> None:
        """Prepend an `int8` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependInt16(self, x):  # -> None:
        """Prepend an `int16` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependInt32(self, x):  # -> None:
        """Prepend an `int32` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependInt64(self, x):  # -> None:
        """Prepend an `int64` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependFloat32(self, x):  # -> None:
        """Prepend a `float32` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def PrependFloat64(self, x):  # -> None:
        """Prepend a `float64` to the Builder buffer.

        Note: aligns and checks for space.
        """
        ...
    def ForceDefaults(self, forceDefaults):  # -> None:
        """
        In order to save space, fields that are set to their default value
        don't get serialized into the buffer. Forcing defaults provides a
        way to manually disable this optimization. When set to `True`, will
        always serialize default values.
        """
        ...
    def PrependVOffsetT(self, x): ...
    def Place(self, x, flags):  # -> None:
        """
        Place prepends a value specified by `flags` to the Builder,
        without checking for available space.
        """
        ...
    def PlaceVOffsetT(self, x):  # -> None:
        """PlaceVOffsetT prepends a VOffsetT to the Builder, without checking
        for space.
        """
        ...
    def PlaceSOffsetT(self, x):  # -> None:
        """PlaceSOffsetT prepends a SOffsetT to the Builder, without checking
        for space.
        """
        ...
    def PlaceUOffsetT(self, x):  # -> None:
        """PlaceUOffsetT prepends a UOffsetT to the Builder, without checking
        for space.
        """
        ...

def vtableEqual(a, objectStart, b):  # -> bool:
    """vtableEqual compares an unwritten vtable to a written vtable."""
    ...
